fix gparted so it only needs (disk group rw privs)
why does it need anything else?
ioctls - which ones?  necessary?
	drive geometry
	without which what can't we do?

disk display:
	linear
	logorithmic

partition display with a disk:
	linear
	logorithmic

text labels
	separate text for:
		disk
		partition
		container
	magic:
		%device		/dev/sda2
		%dev		sda2
		%mounts		/home, /mnt/home
		%filesystem	ext4
		%label		home dirs
		%size		120 GiB
		%used		56 GiB
		%flags		boot
		%partial	stripe, mirror, raid, etc
	escape seq:
		\n		newline
		\r		right align
		\l		left align
		\b		big text
		\s		small text
		\o		ordinary text

able to work on vm image files (raw, vmdk, cow, etc)
choose custom colours
resize "working" dialog
	shouldn't be modal
	should be on/off-able

combo_devices_changed

install all the gtk3 devel libs

configurable sizes:
	bytes/sectors/kilobytes/megabytes/gigabytes/terabytes (and SI versions)
	also percentage
	option for "classic" look of mixed units

device selection
	"all devices" (default) -- run in new mode with all devices visible
	/dev/sda, etc -- run in classic mode examining one device
	compact mode with all devices visible, but vertically compressed

right click on ONE part of a lvm/raid/etc setup and get menus:
	delete WHOLE lvm/raid/etc
	delete THIS part only (breaking raid, mirror, stripe, etc)
	select entire contents (all parts of volume)

save / restore partition metadata

hide protective partitions?
just flag them?
	lvm, gpt, ldm, md

monitor the vg seq num to avoid unnecessary updates
can we checksum the relevant regions of disks for other partition schemes
on "refresh" we check the crc of the data region: save unnecessary updates
can we use inotify to monitor a section of a file/device (ie the first 4K)?

alter watcher to use inotifywait

block size = sector size = extent size = stripe size
	one name for all

icons for
	partial, mirror, stripe, raid

tooltips, context menus

ability to convert between different partition systems?

asynchronously queue up all the actions needed to populate the screen
leave ??? for the as-yet unread stuff
or little clock icons?
wait cursors embedded in the table?

display a measure of fragmentation

support for loop mounted partitions / devices (especially for VMs)

used space is coloured yellow
system space is coloured green? (system/reserved)

put "locked" (mounted) symbol on graphical display, too

option to choose data columns to display

accessor functions for members
get_bytes_size/set_bytes_size
get_size (int block_size /* = 1 (bytes) */
set_size (int block_size /* = 1 (bytes) */
set_used (int block_size /* = 1 (bytes) */
	this updates the free space?
set_free ...
	this updates the used space?
enum UNITS_BYTES, UNITS_SECTORS (dep on hardware), UNITS_BLOCKS, UNITS_CYLINDERS, UNITS_MEBIBYTES instead of a byte count?

after each operation try to minimised the refresh
(i.e. don't re-scan the whole system)

filemanager view which highlights partitions on selection

file open menu to add extra devices, e.g.
	/dev/loop0
	fedora_vm.img

Are you sure?
This operation will destroy:
	2 filesystems
	120 GiB of data
YES NO

code only deals in bytes, display can scale to human where necessary

class Jim -> class CJim?

Are you sure?
Only enable "yes" button after an n-second delay
options to disable all warning messages
[X]	Warning1
[X]	Warning2
[X]	Disable safety delay on Yes button
[X]	Disable "are you sure?" (contingent on above)

incorporate partimage (norton ghost) into gparted

partition wizard features
	Bootable CD 				
	MBR-Style Disk 				
	GPT-Style Disk 				
	Resize Partition 				
	Merge Partition 				
	Hot Extend Partition 				
	Move Partition 				
	Delete Partition 				
	Format Partition 				
	Rebuild MBR 				
	Partition Recovery 				
	Partition Copy 				
	Disk Copy 				
	Wipe Partition 				
	Wipe Disk 				
	Set Primary Partition 				
	Set Logical Partition 				
	FAT 				
	NTFS 				
	Ext2/3/4 				
	Disk Surface Test 				
	Partition Surface Test 				
	Change Partition Serial Number 				
	Change Partition Type ID 				
	Change cluster size without data loss 				
	Convert Dynamic Disk to Basic Disk 				
	Dynamic Disk
	Data Protecting 				

declare functions 'const' if nec

need classes for loop and extended
they need to lie about devices and offsets

actions
	check
	info
	mount
	unmount
	format
	wipe
	label
	set uuid
	set flags

useful tools
	blkid
	lsblk
	findmnt
	blockdev

blockdev --getsize /dev/sda
976773168				# size in 512 byte blocks
blockdev --getsize64 /dev/sda
500107862016				# size in bytes

unique things? map<>
	disk
	uuid
	mount point
	volume group
	partition

device and offset needed
esp. for loop and segments

do (fs|disk|part|etc) specific things

disk -> SMART

lvm -> add mirror, stripe, break mirror

fs convert
	requires asking destination fs for action
	actions for ext2
		convert to btrfs
	should we ask btrfs for actions on other fs?
part scheme convert
lvm convert
encrypt / decrypt
rescue

select
	this segment
	all segments

get_actions -> vector<desc, object, params>
do_action
help_action

multi_select
	fs * n
	partitions * n
	-> delete, check, info

container.find (device) - recurses through children
can give answers
	YES -> pointer
	NO -> does not exist
	DONT_KNOW -> ask someone else

container.find (uuid)
recurse through children
stop on match? unique? dupes?

container.find (mount point)
recurse

/dev/dm-[n]

option show:
	partition size
OR	filesystem size


Display Menu
	Graphical
	Disks
	Partitions
	Logical Volumes
	Mounts

in the top-right corner of each display section, show a |X| to UN-display that element

Blank disk
	Options
		new partition table -> msdos, gpt, etc
		new partition - whole disk
		new lvm? - protective partition?	} What proportion of the disk?
		new ldm? - protective partition?	}

Mounts
	/		/dev/sda1
	/home		/dev/sda2
	/mnt/backup	/sdb1

csv columns
	container type		disk, partition, filesystem
	name			sda, msdos, ext4
	block size		4096
	label			[filesystem only]
	siblings / part of?	necessary?
	device			/dev/sda1
	device offset		1MiB
	size total		total size	}
	size used		in use		} size in bytes, sectors, MiB, GiB, cylinders, %age
	size free		empty space	}
	mounts			/home
	devices			/dev/disk/by-id by-uuid etc
	flags			object specific flags, read-only, broken?
	raid type		mirror, stripe, raid, etc
	children		implied?
	siblings		prev / next?
	parts			list of lvm segments

global maps
	x -> container
	uuid
	device
	name - multimap?
	mount point / mounted *below*
	fs type - multimap

gfx device
signals
	clicked		}		{ disk		}
	double-clicked	} - need to ask { partition	} for options
	right-clicked	}		{ filesystem	}

shadow objects
	gfx_fs
	gfx_part
	etc
derived from non-graphical objects?

don't need to rebuild entire gfx objects unless refreshed (or at end of jobs)
UNLESS: you want a live view of progress

progress dialog is non-modal

highlight working partition

create list of all actions
decide what underlying commands will be executed
decide how that will affect the object hierarchy
decide the minimum number of objects to refresh

what happens to my objects if a simple lvm volume is extended, mirrored, striped, etc?

move members before functions in classes

#ifdef debug around dump_*()

Automatic dump functions
	container ctor
		handle = create_section ("Container");
		add_member (handle, "name", value_reference);
	disk ctor
		handle = create_section ("Disk");
		add_member (handle, "name", value_reference);
Sections: map<name, members>
members: vector<M>
M struct <name, type, pointer>

disk container understands disks
e.g. /dev/hda, sda, etc
logical container understands lvm
e.g. /etc/mapper/myvol-X, /dev/myvol/X
derived from container

lvm partial volume
	icon
	greyed out
	hashed out

Click behaviour
Graphical display
	[DISK] [LVM] [sda1: linear(1/3)] [sda2: linear(2/3)] [sda3: linear(3/3)]
Logical Volumes
	My Vol
		linear
Partitions
	sda
		sda1
		sda2
		sda3
CLICK ON		HIGHLIGHT		HIGHLIGHT		HIGHLIGHT
gfx: linear(2/3)	gfx:linear(2/3)		logical vol: linear	partitions:sda2
gfx: lvm tag		gfx:linear(all3)	logical vol: linear	partitions:sda[123]
lvm: linear		gfx:linear(all3)	logical vol: linear	partitions:sda[123]
part: sda3		gfx:linear(3/3)		logical vol: linear	partitions:sda3

gfx: yellow bar for %age in use; use a colour for %age completion of mirror generation

find out if partition/filesystem is mounted

take a vm image and mount / manipulate the partitions within
after analysis, list the commands needed for the user to do the same

bool container::verify()

change
	int function (in_param, &out_param);
to the less efficient, but clearer
	output = function (in_param);

stripe size -> block_size
if creating a filesystem, take block_size into account

check version of lvm before starting
	LVM version:     2.02.86(2) (2011-07-08)
	Library version: 1.02.65 (2011-07-08)

images - prereq for high-numbered loops in shell script

/var/lib/libvirt/images/fedora-16.img

ifndef __USE_FILE_OFFSET64 
#ifdef __USE_LARGEFILE64 
extern int stat64 (__const char *__restrict __file, 
extern int fstat64 (int __fd, struct stat64 *__buf) __THROW __nonnull ((2)); 

create copy ctors to create backup versions of container trees

partition/fs clone vs copy
	clone = identical bit for bit => same uuid
	copy = efficient duplication, just copy the data regions ($Bitmap)

container::snapshot_create
container::snapshot_revert
	recursively copies / reverts a container tree

register_*
	table
	filesystem
	logical
keep track of "contained by"?

msdos::probe
gpt::probe
	return a valid (populated) container
	offset a parent into which the object gets inserted, but also return the object

reduce/isolate the amount of root-only things
so that a normal user can run it on a loop device, or vm image
without extra privs

new top-level panel for virtual disk images
path, size, %age used, etc

mounts panel
	show all
	show/hide type "tmpfs", etc
	show/hide virtual fs
	show/hide net fs

if I use a stock icon on a panel
will it be themed?

identify - need bytes
	ntfs 512
	swap 4K
	fat 512
	ext2 1024
	btrfs 65K

register probe
	type: table, filesystems, logical
	size: how much to identify self

msdos reads partition table
	knows about / creates: partition, extended, reserved
	queues probe for partition contents

gpt reads partition table
	knows about / creates partition/reserved
	queues probe for partition

partition contains
	empty
	fs
	lvm, etc

container::read (buffer, size)
	does the right thing

filesystems have children?
	vm images withing?
	NO
	but menu highlights owner

btrfs object for snapshots, subvolumes, etc
some for other fs, defrag, fsck, etc

find all the ioctl in fdisk, parted, gparted, etc

build
	alter Makefile to just echo
		CC partition.o
		etc

test case of 100 disks/devices/images
kernel can probably handle 255

Container::add_child
	if bytes_size/bytes_used is < 0 don't alter them

need to be able to identify full, but unrecognisable boot partitions

put a sequence number in every object
increment the seq num on any changes
gfx object can check whether to update themselves
changing an object invalidates all its children
seq number of -1 => object is dead
ref count, too

can I put a text ui on top
	lines of text (tables and stuff)?
	full ncurses?

minimal package set to install/build dparted on
	fedora
	debian
	ubuntu
	mint
	opensuse
=> repository for fedora/suse
=> ppa for debian/ubuntu

for publishing: who should I tell?

what does /proc/partitions say on a virtual machine?
	xen
	kvm
	vmware
	etc

need a way of marking invalid objects
it's probably one of these, but something doesn't make sense
why bother?
what can we do if it's broken?
e.g. msdos partition table
	valid, empty
	valid, partial
	valid, full
	invalid

pre-emptively create object (at first identification)
then log and "delete this" if necessary

int container::preferred_alignment

how to identify an OS on a partition
/etc/system-release for linux
what about windows/bsd/macos/etc
tooltip showing contents:
	"Windows 7"
	"Fedora 16"
	"Dir1\nDir2\nDir3\n..."
must be mirrored by a properties menu option (for accessiblility)
factor out into libos

flags
	general container flags
		valid
		read-only
		etc
	container-type specific flags
		extended partition
		etc

list of error conditions for every function
errno, etc

along with each test image
need a broken image testing every "if (!x)" in the entire program
fuzzing tool?
	corrupt tables
	zero lengths
	size overruns
	read failed
	command not found
	command output corrupt

check all the necessary commands exist
continue without them, if possible?

check all return paths for releasing buffers

Container::read_data must be limited to block_size
otherwise the data could span different locations

minimum/maximum sizes for volumes, filesystems, etc

move iprintf (indented) to log.cpp

force fflush of log?

build-in test mode into gui
	create some loop devices
	create some demo partitions, volumes, etc

as well as reading the filesystem magic, we should try to read the fs size
and validate it against its container

move mount handling into mounts.cpp?

lvm, md, ldm as separate plugins
filesystems should be pluggable too

reduce reliance on command line tools -- use shared libraries where possible

should the volumegroup object keep a list of free segments?

make sure we're using all the lvm fields we ask for

watcher -- crashes when there's no 'vi' window

examine guestfs-browser

shorten uuids
vim
	:%s/\([a-z0-9]\{6}\)\(-[a-z0-9]\{4}\)\{5}-[a-z0-9]\{6}/\1 /
	:%s/\C\(UUID \)                               /\1/
sed
	-e 's/\([A-Za-z0-9]\{6\}\)\(-[A-Za-z0-9]\{4\}\)\{5\}-[A-Za-z0-9]\{6\}/\1 /g'
	-e 's/\(UUID \)                               /\1/g'

trying reversing the lvm sort field to test the code assembly

create test case with lots of duplicate names
duplicate uuids too?

use scanf a LOT more

container::is_valid()
	do a sanity check on this object and all its children

reset terminal
echo -en "\ec" > /dev/pts/1
use it in log_init()

could log different levels to different files / ttys

LOG_ENTER macro that references __FUNCTION__
enables per function logging!

mmap example for read/write

remove/separate junk dir using git filter

copy lvm code to check for open file descriptors on exit?

change open -> fopen

container.h need forward def for FILE*

read-only
	command line option
	preferences option
	compile-time option

get a list of supported filesystems
/proc/filesystems

define DISABLE_DEPRECATED

expanding treeview rows to highlight current selection

drag'n'drop partition moving
if you drop a large partition into a smaller space, it will offer to shrink the volume (if that's possible)
or move things out of the way

determine what to do for single/multiple selections in the treeview

treeview double-click -> infobox

preferences dialog
tabbed (notebook) of options
OK, Cancel, Cautious (set defaults for a novice user), Expert (select defaults for an expert user)

for plugins we need to register
	partition_table
	filesystem
	volume manager?

keyboard control
tab between items
F6 to switch sections
Shift-F10 (or Menu) for context menu
what about arrows? left/right/up/down?

command line option - read-only

give Container the ability to store user-supplied info
(for the benefit of the gui)

timer watching filesystems:
	filesystem mounted
	filesystem unmounted
	mounted filesystem freespace has changed!

lib_identify_filesystem
lib_identify_operating_system

view menu: Labels
name gui disks with fs labels (if poss)

need test cases for differently-sized disks
test display strategies
	disk: linear, logorithmic
	partition: linear, logorithmic

ability to save details of actions
after and *before* operations
make it a list of commands that can the copied

have two modes: live and queued
expert live mode make changes are you click on things
novice queued mode, queues the changes, explains them and then waits for OK

top-level devices:
	disk
	loop
	file
	network

fix image creation tools to:
	 check that enough loops exist
	 pick a loop device and use that one
	 destroy should look for the image name in losetup -a

use css to theme the colours,font,icons?

theme:
	light
	dark
	auto - guess from the default colours
	custom - filename.css

filesystem option: open in nautilus ("View files")
may require mounting the filesystem
watch fuser - unmount automatically?

make the drawing area completely self-container
i.e. pluggable into another app
properties to control
	colour scheme
	tooltips
	etc
would need plenty of overridable methods

when performing operations what should the cancel button do?
between operations:
	stop work
	list of what got done
	list of what didn't get done
mid large operation:
	nothing un-reversable has happened, therefore ok
	some potential for undo? back to sane state
	"this will destroy...", continue y/n
	cancel should SIGSTOP all operations until further notice

for partition move, only move the data (read the bitmap)

image tools - use losetup -f file.img
grep name from losetup -a
safely get device without race condition

does r/o loop mounting a fs alter the last mounted time?
if not I can keep track of the filesystem contents
	mount r/o loop
	get fs type
	get os type
	get file listing for root dir
	record last mounted time
later when needing the data again
if mounted time has changed, rescan fs
if not used cached data

on a timer, keep track of
	free space in mounted filesystems / swap devices
	last mount time of unmounted filesystems
	list of mounted filesystems
	list of loop devices
	list of lvm volumes, etc

remove all container knowledge from drawingarea?

disable clipping regions onces tested and range-checked

themeable items
	colours
	icons
	sizes
	text layout
	gradients

option for scanning
	ignore empty (don't give me object for empty spaces)
	ignore reserved (leave gaps, instead of reserved objects)

base class CRefCount
	reference()
	unreference()

test mode fixes the theme -- sizes, colours, fonts, etc
lie about device names too -- all "/dev/sda"
make the output easily cut'n'pasteable

test cases
	disk, empty
	disk, unknown
	disk, filesystem

	disk, msdos table, empty
	disk, msdos table, partition, empty
	disk, msdos table, partition, filesystem
	disk, msdos table, partition, unknown
	disk, msdos table, (partition, filesystem) * 4					(include empty space)

	disk, msdos table, extended partition, empty
	disk, msdos table, extended partition, partition, empty
	disk, msdos table, extended partition, partition, unknown
	disk, msdos table, extended partition, partition, filesystem
	disk, msdos table, extended partition, (partition, filesystem) * 8		(include empty space)

	disk, protective table, partition, empty
	disk, protective table, partition, gpt table, empty
	disk, protective table, partition, gpt table, partition, empty
	disk, protective table, partition, gpt table, partition, unknown
	disk, protective table, partition, gpt table, (partition, filesystem) * 8	(include empty space)

	disk, gpt table, empty
	disk, gpt table, partition, empty
	disk, gpt table, partition, unknown
	disk, gpt table, (partition, filesystem) * 8					(include empty space)

	disk, protective table, partition, lvm table, empty
	disk, protective table, partition, lvm table, unknown
	disk, protective table, partition, lvm table, partition, empty
	disk, protective table, partition, lvm table, partition, unknown
	disk, protective table, partition, lvm table, partition, filesystem
	disk, protective table, partition, lvm table, (partition, filesystem) * 8	(include empty space)

	disk, lvm table, empty
	disk, lvm table, unknown
	disk, lvm table, partition, empty
	disk, lvm table, partition, unknown
	disk, lvm table, partition, filesystem
	disk, lvm table, (partition, filesystem) * 8	(include empty space)

	test different filesystem types
		one of each type - ext2, ext3, ext4, reiser, btrfs, jfs, xfs, swap, fat, fat32, ntfs
		space before and after each partition
		able to
			resize
			move
			create
			delete
			format
			info
			check
			label
			uuid

	test different lvm configurations
		linear
			1 segment
			many segments
				add segment
				remove segment
		stripe
			2 stripes
			many stripes
				add stripe
				remove stripe
				add mirror
		mirror
			2 mirrors
			many mirrors
				add mirror
				remove mirror
				break mirror
		raid10 (mirrored stripes)
			2 mirrors
			many mirrors
				add mirror
				remove mirror
			2 stripes
			many stripes
				add stripe
				remove stripe

	test different tables
		empty disk
		create table
			msdos
			gpt
			lvm
		convert one table type to another

	misc
		filesystem smaller than the partition
			display empty space
			allow enlarging filesystem
		filesystem larger  than the partition!
			whole disk readonly
			replace block icon with STOP sign
		alignment of partitions
			none
			sector
			cylinder
			megabyte
		multiple, independent, volume groups on one disk
		test gfx on LARGE numbers of volumes


scripts, fold error conditions:
	LOOP="$(create_loop $FUNCNAME)"
	[ -n "$LOOP" ] || error || return
becomes
	LOOP="$(create_loop $FUNCNAME)" || error || return

on delete partition offer to clean up
	do nothing
	write zeroes over the beginning of the partition
	write zeroes over the entire partition
	shred the entire partition
fewer options
	Delete:
		Are you sure? [y/N]
		Secure deletion [y/N]

identify LUKS partitions and offer to open/close them
need an icon

support MS LBA extended partition 0x0f

test scripts
	-v verbose
	-d delete

test cases for LDM, md

reserved space?
	ignore it in the diskgui?

unallocated vs empty partition -- distinguish them

have own icons
otherwise doesn't match docs
easier to keep things aligned
need a dark set too

have a "dark" colour scheme

identify protective partitions in the lib

short fs (doesn't fill the container)
less white bit

autosize text (vertically) to fit disk gui
count the number of lines we can get away with

fs > partition size -- now what?

option to show/hide reserved space

are !'s visible enough to use in gui?

when working (performing disk actions)
highlight the current partition (red)?

vim cpp <leader> + ?
	m make
		use makeprg or shellpipe to duplicate output to other window
	first time, find the place and mark it
	second time jump to the mark
	open fold

colour-code table blocks in disk-gui?
too much?
how do we distinguish between...?
	disk, msdos, partition
	disk, lvm, partition

which items should be folded?
container + child == same size
child = filesystem

gap 2px before and 1 after?

handle 10px?

list of custom signals

prelight drawing area on hover => clickable
tooltip on hover

treeiter on container

comments on docs a la mysql

handles on disk, extended, lvm -- not disk?
anything with multiple children
disk,loop,file => icon

hide
	partition table?
	partition?
	protective partition?

gparted table fields
	0 Partition
	1 Filesystem
	2 Mount point
	3 Label
	4 Size
	5 Used
	6 Unused
	7 Flags

empty partition objects can ask parents for actions

clicking on the disk gui should expand the tree view if necessary

tooltips
disk
	ICON
	Model: ATA Maxtor
	Size 298GiB
	Free/Used space (pie chart?)
	device: /dev/sdc (8,32)
	Partition table: msdos
	CHS x,y,z
	Sectors: 1234
	Sector size: 512
Extended
	sdc2
	size 150G
	3 logical partitions
	free/used space
table
	msdos partition table
	5 data partitions (2 primary, 3 logical)
	free/used space
partition
	type
	size
	free/used space
filesystem (include in partition/whoever the parent is)
	type
	size
	block size
	free/used
	fragmentation
	etc

if we have object for empty spaces, we need rules for coalescing empty spaces
empty != reserved, etc

localisation on object names
no localisation in the lib

put some limit on what containers can contain?
what about new types (plugins) how do we know where to find them?

vector<> container::get_free_space

loop:find_devices()

lvm
	linear	=> no dependents : 1-n volumes
	striped => n * linear volumes
	mirror => log + n * volumes (linear or striped)

/sys/block/X/size

get list of devices from /proc/partitions or blkid
	disk
	loop
	file
	net?
don't need to probe these fundamental types

Using each disk/loop/file device/offset
	for each parition table probe
		read one sector and pass it to msdos, gpt, etc
		in liklihood order
	for each logical volume type: lvm, ldm, md, etc
	for each filesystem type: etc2,3,4, fat, ntfs, etc
		first probe the common ones and those that
		require the least disk reading

at each level of probing there are three outcomes
	No: not my type, try someone else
	Yes: I've dealt with it, nothing more to do
	Yes: Probe my children

raid10 = mirrored stripes, i.e.
	1 mirror that contains (a log and)
	4 stripes that contain
	8 linear volumes

PVSEG_START = PV offset
SEG_START_PE = LV offset

theme contains icon names too
plugin filesystem/table can set theme info for itself

change all the gfx parameters to doubles
if the backend is swapped for svg it will still look good
could be used to save appearance

need to add alpha to all the colours I use from the theme
(even if *I* don't want to use it)
could be used for debugging by making certain elements translucent

theme change the names to
	fs_ntfs
	fs_ext2
	table_msdos
	table_gpt
if "table_X" doesn't exist, use "table", etc

changing the theme to "default" could re-call init_colours, etc
send a signal afterwards to alert plugins

svg icons would mean a completely scalable output

theme needs to contain
	diskgui height
	coloured bar height (hence radius)
	NOT left-tabwidth (?) - measured from ALL the icons?
	left-tabwidth - clip all the icons
fix the icon widths and diskgui height for three modes?
	small 24	~64
	medium 48	~77
	large 48	~128

theme get_colour
if not in map, try rendering the string directly

grep test_22 -l /sys/block/loop*/loop/backing_file
/sys/block/loop0/loop/backing_file
find which loop device has a file

draw a scale on the disk gui
especially for the non-linear scaling

view menu: key detailing colours and icons

advanced menu option to view an unknown partition in a hex viewer

tests
	multiple lvm volume groups on a single disk
	(in different partitions)

context menu
	highlight parent
	highlight siblings (other pieces of me)
	highlight children

"No Volume groups found"
if pvs returns nothing, don't search for volumes groups or volumes

for redundant volumes have flags on the group object to determine which device to read from
first, last, random, etc

in disk gui only drop "/dev/" not everything up to "/"
therefore
	/dev/sda1 -> sda1
	/dev/mapper/bob -> mapper/bob

#includes
check I need them all
include bare minimum gdk/gtk for speed
eliminate #include <gtkmm.h>

junk makefile: updating src doesn't invalidate bin

change the log functions into a log object?
dtor would close the log

to find the lvm volumes I only need
	vgs + lvs
pvs doesn't get me any info that I can't get from these two

lvm tests with missing devices
	enough devices for recovery
	not enough devices for recovery

list everything that could throw an exception and put in handlers

only autowrite and autohide for files in my work directory (and below)

speed up build by only compiling gui src with gtkmm, etc

add a log_debug (DPContainer *) and ref to dump the object

replace 0x%02x with %#02x

factor out partition naming function

replace
	buffer = (unsigned char*) malloc (bufsize);
with vector<unsigned char>

only double-click (un)fold on source files

white curvy corners should get their colour from the theme too

LogQuell object
	when instantiated it prevents [some/all] logging
	when it is destroyed, logging is returned to normal
how do you conditionally create an object without hassle or leakage?

script to turn existing partition table into a image_build script
e.g.
	copy_table.sh /dev/sda
creates
	sda_image.sh
builds
	/dev/loop0
with matching
		partition table
		partition layout
		filesystems
		%age file usage (fallocate)

adapt draw_grid_linear et al to fit into a partition frame
partition_clone program to save a sparse image of the same

dparted --test
lots of sample disks to play with
non-destructive, but persistant (across runs) -- save to config file, etc
reset menu item
[X] extra realism -- take ages to perform moves!

todo directory, split up this file

factor out gpt,msdos,etc code into
	libgpt
	libmsdos
	etc

drawingarea -- need custom cases for small partitions
(down as small as 1px wide?)

change objects to be "filled" with a space object
if add_child is called the space is either replaced
or split around the child

container public function get_children (enum TYPES)
	child
	space
	reserved

test case 12.5 a filesystem that doesn't fill the disk

vgsplit	split volume group into separate vg's
vgmerge join two vg's into one

