log output -> callback function

log::dot
	cache output
	spawn dot on flush

log::code
	can't be caused by user operation
	effectively an assert

logging: config file -- script to manipulate log destinations
	log_me [log_level]
	runs tty

log level push object cf LOG_TRACE

template<type X> X log return (X) calls logtrace leaving(X) (retval, line no)

log -> cout? (still use varargs, printf format)

main -v => log_info, main -vv => log_debug

move iprintf (indented) to log.cpp

force fflush of log?

reset terminal
echo -en "\ec" > /dev/pts/1
use it in log_init()

could log different levels to different files / ttys

LOG_ENTER macro that references __FUNCTION__
enables per function logging!

change the log functions into a log object?
dtor would close the log

add a log_debug (DPContainer *) and ref to dump the object

LogQuell object
	when instantiated it prevents [some/all] logging
	when it is destroyed, logging is returned to normal
how do you conditionally create an object without hassle or leakage?

int log_XXX (const char *format, ...) __attribute__ ((format (printf, 1, 2)));

bool log_init (const char *name);
void log_close (void);

unsigned int log_set_level (unsigned int level);
unsigned int log_get_level (void);

uniq log line numbers
	partition numbers
	translate strings

log_info (spec)
log::info << streamystuff << ...
log::info.format (spec)

automatic creation, cf std::cout

stream
printf

enable (bitfield)	} function or object (scoped)?
disable (bitfield)	}
push/pop (bitfield)
quell to end of function
log_enter/exit function

initialise global, or per stream
	output file/tty
	colour
	timestamp

trace ctor def params __FILE__ etc defined in .h _which_ file?

namespace Log {

class Debug : public log -> public iostream {};

Log::Debug << xyz << std::endl;
Log::Debug.printf ("format %s\n", X);
Log::printf (Log::Debug, "format %s\n", X);

uniq id for all throws cf log

single exit point for all logging
	i.e. different handles, but one command

